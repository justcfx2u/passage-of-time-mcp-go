package main

import (
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"
)

// XML structure for CLDR windowsZones.xml
type SupplementalData struct {
	XMLName     xml.Name    `xml:"supplementalData"`
	WindowsZones WindowsZones `xml:"windowsZones"`
}

type WindowsZones struct {
	XMLName     xml.Name     `xml:"windowsZones"`
	MapTimezones MapTimezones `xml:"mapTimezones"`
}

type MapTimezones struct {
	XMLName  xml.Name  `xml:"mapTimezones"`
	MapZones []MapZone `xml:"mapZone"`
}

type MapZone struct {
	XMLName   xml.Name `xml:"mapZone"`
	Other     string   `xml:"other,attr"`     // Windows timezone name
	Territory string   `xml:"territory,attr"` // Territory code (001 = global)
	Type      string   `xml:"type,attr"`      // IANA timezone(s)
}

const cldrURL = "https://raw.githubusercontent.com/unicode-org/cldr/refs/heads/main/common/supplemental/windowsZones.xml"

func main() {
	fmt.Println("ğŸŒ Unicode CLDR Windows Timezone Mapping Generator")
	fmt.Println("=================================================")
	
	// Download the XML file
	fmt.Printf("ğŸ“¥ Downloading: %s\n", cldrURL)
	resp, err := http.Get(cldrURL)
	if err != nil {
		fmt.Printf("âŒ Failed to download: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != 200 {
		fmt.Printf("âŒ HTTP error: %d %s\n", resp.StatusCode, resp.Status)
		os.Exit(1)
	}
	
	// Read the XML content
	xmlData, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("âŒ Failed to read response: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("âœ… Downloaded %d bytes\n", len(xmlData))
	
	// Parse the XML
	var data SupplementalData
	err = xml.Unmarshal(xmlData, &data)
	if err != nil {
		fmt.Printf("âŒ Failed to parse XML: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("âœ… Parsed %d timezone mappings\n", len(data.WindowsZones.MapTimezones.MapZones))
	
	// Process the mappings
	mappings := make(map[string]string)
	var globalMappings []MapZone
	var territorySpecific []MapZone
	
	for _, zone := range data.WindowsZones.MapTimezones.MapZones {
		if zone.Territory == "001" {
			// Global mapping - these are our primary candidates
			globalMappings = append(globalMappings, zone)
			
			// Handle multiple IANA timezones (space-separated)
			ianaZones := strings.Fields(zone.Type)
			if len(ianaZones) > 0 {
				// Use the first IANA timezone as primary
				mappings[zone.Other] = ianaZones[0]
			}
		} else {
			// Territory-specific mapping
			territorySpecific = append(territorySpecific, zone)
		}
	}
	
	fmt.Printf("ğŸ“Š Global mappings: %d\n", len(globalMappings))
	fmt.Printf("ğŸ“Š Territory-specific mappings: %d\n", len(territorySpecific))
	fmt.Printf("ğŸ“Š Unique Windows timezones: %d\n", len(mappings))
	
	// Show sample mappings
	fmt.Println("\nğŸ” Sample Mappings:")
	var sortedKeys []string
	for k := range mappings {
		sortedKeys = append(sortedKeys, k)
	}
	sort.Strings(sortedKeys)
	
	sampleCount := 10
	if len(sortedKeys) < sampleCount {
		sampleCount = len(sortedKeys)
	}
	
	for i := 0; i < sampleCount; i++ {
		key := sortedKeys[i]
		fmt.Printf("  %s â†’ %s\n", key, mappings[key])
	}
	
	if len(sortedKeys) > sampleCount {
		fmt.Printf("  ... and %d more\n", len(sortedKeys)-sampleCount)
	}
	
	// Look for key Windows timezones
	fmt.Println("\nğŸ¯ Key Windows Timezones:")
	keyTimezones := []string{
		"Eastern Standard Time",
		"Pacific Standard Time", 
		"Central Standard Time",
		"Mountain Standard Time",
		"GMT Standard Time",
	}
	
	for _, tz := range keyTimezones {
		if iana, exists := mappings[tz]; exists {
			fmt.Printf("  âœ… %s â†’ %s\n", tz, iana)
		} else {
			fmt.Printf("  âŒ %s â†’ NOT FOUND\n", tz)
		}
	}
	
	// Generate Go code structure preview
	fmt.Println("\nğŸ“ Go Code Structure Preview:")
	fmt.Println("var WindowsToIANA = map[string]string{")
	
	previewCount := 5
	for i := 0; i < previewCount && i < len(sortedKeys); i++ {
		key := sortedKeys[i]
		fmt.Printf("    %q: %q,\n", key, mappings[key])
	}
	fmt.Println("    // ... more mappings")
	fmt.Println("}")
	
	fmt.Printf("\nâœ… Ready to generate Go mapping file with %d timezone mappings\n", len(mappings))
	
	// Generate the Go source file
	fmt.Println("\nğŸ“ Generating windows_timezone_mapping.go...")
	err = generateGoFile(mappings)
	if err != nil {
		fmt.Printf("âŒ Failed to generate Go file: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println("âœ… Successfully generated windows_timezone_mapping.go")
}

func generateGoFile(mappings map[string]string) error {
	// Create the Go source file content
	var content strings.Builder
	
	// File header
	content.WriteString("// Code generated by generate-timezone-mapping tool. DO NOT EDIT.\n")
	content.WriteString("// Generated from Unicode CLDR windowsZones.xml\n")
	content.WriteString("// Source: https://raw.githubusercontent.com/unicode-org/cldr/refs/heads/main/common/supplemental/windowsZones.xml\n")
	content.WriteString("\npackage main\n\n")
	
	// Documentation
	content.WriteString("// WindowsToIANA maps Windows timezone names to IANA timezone identifiers.\n")
	content.WriteString("// This mapping is based on the Unicode CLDR (Common Locale Data Repository)\n")
	content.WriteString("// windowsZones.xml file, which is the authoritative source for timezone mappings.\n")
	content.WriteString("//\n")
	content.WriteString("// Examples:\n")
	content.WriteString("//   \"Eastern Standard Time\"     -> \"America/New_York\"\n")
	content.WriteString("//   \"Pacific Standard Time\"     -> \"America/Los_Angeles\"\n")
	content.WriteString("//   \"Central European Time\"     -> \"Europe/Berlin\"\n")
	content.WriteString("var WindowsToIANA = map[string]string{\n")
	
	// Sort the keys for consistent output
	var sortedKeys []string
	for k := range mappings {
		sortedKeys = append(sortedKeys, k)
	}
	sort.Strings(sortedKeys)
	
	// Generate the map entries
	for _, key := range sortedKeys {
		value := mappings[key]
		content.WriteString(fmt.Sprintf("\t%q: %q,\n", key, value))
	}
	
	content.WriteString("}\n")
	
	// Additional helper function
	content.WriteString("\n// GetIANATimezone converts a Windows timezone name to IANA timezone.\n")
	content.WriteString("// Returns the IANA timezone and true if found, empty string and false if not found.\n")
	content.WriteString("func GetIANATimezone(windowsTimezone string) (string, bool) {\n")
	content.WriteString("\tiana, exists := WindowsToIANA[windowsTimezone]\n")
	content.WriteString("\treturn iana, exists\n")
	content.WriteString("}\n")
	
	// Statistics comment
	content.WriteString(fmt.Sprintf("\n// Generated with %d Windows timezone mappings\n", len(mappings)))
	content.WriteString(fmt.Sprintf("// Total CLDR mappings processed: %d\n", len(mappings)))
	
	// Write to file
	outputPath := "windows_timezone_mapping.go"
	err := os.WriteFile(outputPath, []byte(content.String()), 0644)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}
	
	fmt.Printf("ğŸ“„ Generated file: %s (%d bytes)\n", outputPath, len(content.String()))
	return nil
}